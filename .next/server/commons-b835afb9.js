"use strict";exports.id=932,exports.ids=[932],exports.modules={7407:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}(t,{Postpone:function(){return k},abortAndThrowOnSynchronousRequestDataAccess:function(){return E},abortOnSynchronousPlatformIOAccess:function(){return D},accessedDynamicData:function(){return _},annotateDynamicAccess:function(){return M},consumeDynamicAccess:function(){return O},createDynamicTrackingState:function(){return l},createDynamicValidationState:function(){return y},createPostponedAbortSignal:function(){return U},formatDynamicAPIAccesses:function(){return j},getFirstDynamicReason:function(){return f},isDynamicPostpone:function(){return x},isPrerenderInterruptedError:function(){return P},markCurrentScopeAsDynamic:function(){return h},postponeWithTracking:function(){return A},throwIfDisallowedDynamic:function(){return q},throwToInterruptStaticGeneration:function(){return m},trackAllowedDynamicAccess:function(){return V},trackDynamicDataInDynamicRender:function(){return g},trackFallbackParamAccessed:function(){return p},trackSynchronousPlatformIOAccessInDev:function(){return b},trackSynchronousRequestDataAccessInDev:function(){return S},useDynamicRouteParams:function(){return W}});let r=function(e){return e&&e.__esModule?e:{default:e}}(n(6428)),a=n(2819),o=n(8235),i=n(3033),s=n(9294),c=n(8040),u=n(6253),d="function"==typeof r.default.unstable_postpone;function l(e){return{isDebugDynamicAccesses:e,dynamicAccesses:[],syncDynamicExpression:void 0,syncDynamicErrorWithStack:null}}function y(){return{hasSuspendedDynamic:!1,hasDynamicMetadata:!1,hasDynamicViewport:!1,hasSyncDynamicErrors:!1,dynamicErrors:[]}}function f(e){var t;return null==(t=e.dynamicAccesses[0])?void 0:t.expression}function h(e,t,n){if((!t||"cache"!==t.type&&"unstable-cache"!==t.type)&&!e.forceDynamic&&!e.forceStatic){if(e.dynamicShouldError)throw new o.StaticGenBailoutError(`Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${n}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);if(t){if("prerender-ppr"===t.type)A(e.route,n,t.dynamicTracking);else if("prerender-legacy"===t.type){t.revalidate=0;let r=new a.DynamicServerError(`Route ${e.route} couldn't be rendered statically because it used ${n}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);throw e.dynamicUsageDescription=n,e.dynamicUsageStack=r.stack,r}}}}function p(e,t){let n=i.workUnitAsyncStorage.getStore();n&&"prerender-ppr"===n.type&&A(e.route,t,n.dynamicTracking)}function m(e,t,n){let r=new a.DynamicServerError(`Route ${t.route} couldn't be rendered statically because it used \`${e}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);throw n.revalidate=0,t.dynamicUsageDescription=e,t.dynamicUsageStack=r.stack,r}function g(e,t){t&&"cache"!==t.type&&"unstable-cache"!==t.type&&("prerender"===t.type||"prerender-legacy"===t.type)&&(t.revalidate=0)}function w(e,t,n){let r=v(`Route ${e} needs to bail out of prerendering at this point because it used ${t}.`);n.controller.abort(r);let a=n.dynamicTracking;a&&a.dynamicAccesses.push({stack:a.isDebugDynamicAccesses?Error().stack:void 0,expression:t})}function D(e,t,n,r){let a=r.dynamicTracking;return a&&null===a.syncDynamicErrorWithStack&&(a.syncDynamicExpression=t,a.syncDynamicErrorWithStack=n),w(e,t,r)}function b(e){e.prerenderPhase=!1}function E(e,t,n,r){let a=r.dynamicTracking;throw a&&null===a.syncDynamicErrorWithStack&&(a.syncDynamicExpression=t,a.syncDynamicErrorWithStack=n,!0===r.validating&&(a.syncDynamicLogged=!0)),w(e,t,r),v(`Route ${e} needs to bail out of prerendering at this point because it used ${t}.`)}let S=b;function k({reason:e,route:t}){let n=i.workUnitAsyncStorage.getStore();A(t,e,n&&"prerender-ppr"===n.type?n.dynamicTracking:null)}function A(e,t,n){I(),n&&n.dynamicAccesses.push({stack:n.isDebugDynamicAccesses?Error().stack:void 0,expression:t}),r.default.unstable_postpone(R(e,t))}function R(e,t){return`Route ${e} needs to bail out of prerendering at this point because it used ${t}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`}function x(e){return"object"==typeof e&&null!==e&&"string"==typeof e.message&&$(e.message)}function $(e){return e.includes("needs to bail out of prerendering at this point because it used")&&e.includes("Learn more: https://nextjs.org/docs/messages/ppr-caught-error")}if(!1===$(R("%%%","^^^")))throw Error("Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js");let T="NEXT_PRERENDER_INTERRUPTED";function v(e){let t=Error(e);return t.digest=T,t}function P(e){return"object"==typeof e&&null!==e&&e.digest===T&&"name"in e&&"message"in e&&e instanceof Error}function _(e){return e.length>0}function O(e,t){return e.dynamicAccesses.push(...t.dynamicAccesses),e.dynamicAccesses}function j(e){return e.filter(e=>"string"==typeof e.stack&&e.stack.length>0).map(({expression:e,stack:t})=>(t=t.split("\n").slice(4).filter(e=>!(e.includes("node_modules/next/")||e.includes(" (<anonymous>)")||e.includes(" (node:"))).join("\n"),`Dynamic API Usage Debug - ${e}:
${t}`))}function I(){if(!d)throw Error("Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js")}function U(e){I();let t=new AbortController;try{r.default.unstable_postpone(e)}catch(e){t.abort(e)}return t.signal}function M(e,t){let n=t.dynamicTracking;n&&n.dynamicAccesses.push({stack:n.isDebugDynamicAccesses?Error().stack:void 0,expression:e})}function W(e){{let t=s.workAsyncStorage.getStore();if(t&&t.isStaticGeneration&&t.fallbackRouteParams&&t.fallbackRouteParams.size>0){let n=i.workUnitAsyncStorage.getStore();n&&("prerender"===n.type?r.default.use((0,c.makeHangingPromise)(n.renderSignal,e)):"prerender-ppr"===n.type?A(t.route,e,n.dynamicTracking):"prerender-legacy"===n.type&&m(e,t,n))}}}let B=/\n\s+at Suspense \(<anonymous>\)/,N=RegExp(`\\n\\s+at ${u.METADATA_BOUNDARY_NAME}[\\n\\s]`),G=RegExp(`\\n\\s+at ${u.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`),L=RegExp(`\\n\\s+at ${u.OUTLET_BOUNDARY_NAME}[\\n\\s]`);function V(e,t,n,r,a){if(!L.test(t)){if(N.test(t)){n.hasDynamicMetadata=!0;return}if(G.test(t)){n.hasDynamicViewport=!0;return}if(B.test(t)){n.hasSuspendedDynamic=!0;return}if(r.syncDynamicErrorWithStack||a.syncDynamicErrorWithStack){n.hasSyncDynamicErrors=!0;return}else{let r=function(e,t){let n=Error(e);return n.stack="Error: "+e+t,n}(`Route "${e}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`,t);n.dynamicErrors.push(r);return}}}function q(e,t,n,r){let a,i,s;if(n.syncDynamicErrorWithStack?(a=n.syncDynamicErrorWithStack,i=n.syncDynamicExpression,s=!0===n.syncDynamicLogged):r.syncDynamicErrorWithStack?(a=r.syncDynamicErrorWithStack,i=r.syncDynamicExpression,s=!0===r.syncDynamicLogged):(a=null,i=void 0,s=!1),t.hasSyncDynamicErrors&&a)throw s||console.error(a),new o.StaticGenBailoutError;let c=t.dynamicErrors;if(c.length){for(let e=0;e<c.length;e++)console.error(c[e]);throw new o.StaticGenBailoutError}if(!t.hasSuspendedDynamic){if(t.hasDynamicMetadata){if(a)throw console.error(a),new o.StaticGenBailoutError(`Route "${e}" has a \`generateMetadata\` that could not finish rendering before ${i} was used. Follow the instructions in the error for this expression to resolve.`);throw new o.StaticGenBailoutError(`Route "${e}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateMetadata\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`)}if(t.hasDynamicViewport){if(a)throw console.error(a),new o.StaticGenBailoutError(`Route "${e}" has a \`generateViewport\` that could not finish rendering before ${i} was used. Follow the instructions in the error for this expression to resolve.`);throw new o.StaticGenBailoutError(`Route "${e}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateViewport\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`)}}}},3288:(e,t,n)=>{function r(e){return function(){let{cookie:t}=e;if(!t)return{};let{parse:r}=n(9219);return r(Array.isArray(t)?t.join("; "):t)}}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"getCookieParser",{enumerable:!0,get:function(){return r}})},8182:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"collectSegmentData",{enumerable:!0,get:function(){return u}});let r=n(4521),a=n(4981),o=n(4480),i=n(387),s=n(4240),c=n(5711);async function u(e,t,n,s){let u=new Map;try{await (0,a.createFromReadableStream)((0,i.streamFromBuffer)(e),{serverConsumerManifest:s}),await (0,c.waitAtLeastOneReactRenderTask)()}catch{}let l=new AbortController,y=async()=>{await (0,c.waitAtLeastOneReactRenderTask)(),l.abort()},f=[],{prelude:h}=await (0,o.prerender)((0,r.jsx)(d,{fullPageDataBuffer:e,serverConsumerManifest:s,clientModules:n,staleTime:t,segmentTasks:f,onCompletedProcessingRouteTree:y}),n,{signal:l.signal,onError(){}}),p=await (0,i.streamToBuffer)(h);for(let[e,t]of(u.set("/_tree",p),await Promise.all(f)))u.set(e,t);return u}async function d({fullPageDataBuffer:e,serverConsumerManifest:t,clientModules:n,staleTime:r,segmentTasks:o,onCompletedProcessingRouteTree:s}){let c=await (0,a.createFromReadableStream)(function(e){let t=e.getReader();return new ReadableStream({async pull(e){for(;;){let{done:n,value:r}=await t.read();if(!n){e.enqueue(r);continue}return}}})}((0,i.streamFromBuffer)(e)),{serverConsumerManifest:t}),u=c.b,d=c.f;if(1!==d.length&&3!==d[0].length)return console.error("Internal Next.js error: InitialRSCPayload does not match the expected shape for a prerendered page during segment prefetch generation."),null;let y=d[0][0],h=d[0][1],p=d[0][2],m=await l(y,u,h,e,n,t,"","",o),g=await f(p,n);return s(),{buildId:u,tree:m,head:p,isHeadPartial:g,staleTime:r}}async function l(e,t,n,r,a,o,i,s,u){let d=null,f=e[1],h=null!==n?n[2]:null;for(let e in f){let n=f[e],s=n[0],c=null!==h?h[e]:null,y=i+"/"+function(e,t){let n;if("string"==typeof t)n=p(t);else{let e;let[r,a,o]=t;switch(o){case"c":case"ci":e=`[...${r}]`;break;case"oc":e=`[[...${r}]]`;break;case"d":case"di":e=`[${r}]`;break;default:throw Error("Unknown dynamic param type")}n=`${e}-${p(a)}`}return"children"===e?`${n}`:`@${e}/${n}`}(e,s),g=await m(i,e),w=await l(n,t,c,r,a,o,y,g,u);null===d&&(d={}),d[e]=w}return null!==n&&u.push((0,c.waitAtLeastOneReactRenderTask)().then(()=>y(t,n,i,s,a))),{path:""===i?"/":i,token:s,slots:d,extra:[e[0],!0===e[4]]}}async function y(e,t,n,r,a){let s=t[1],u={buildId:e,rsc:s,loading:t[3],isPartial:await f(s,a)},d=new AbortController;(0,c.waitAtLeastOneReactRenderTask)().then(()=>d.abort());let{prelude:l}=await (0,o.prerender)(u,a,{signal:d.signal,onError(){}}),y=await (0,i.streamToBuffer)(l);return""===n?["/",y]:[`${n}.${r}`,y]}async function f(e,t){let n=!1,r=new AbortController;return(0,c.waitAtLeastOneReactRenderTask)().then(()=>{n=!0,r.abort()}),await (0,o.prerender)(e,t,{signal:r.signal,onError(){}}),n}let h=/^[a-zA-Z0-9\-_@]+$/;function p(e){return e===s.UNDERSCORE_NOT_FOUND_ROUTE?"_not-found":h.test(e)?e:"$"+Buffer.from(e,"utf-8").toString("base64url")}async function m(e,t){let n=new TextEncoder().encode(e+t);return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256",n))).map(e=>e.toString(16).padStart(2,"0")).join("")}},8055:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}(t,{Postpone:function(){return k},abortAndThrowOnSynchronousRequestDataAccess:function(){return E},abortOnSynchronousPlatformIOAccess:function(){return D},accessedDynamicData:function(){return _},annotateDynamicAccess:function(){return M},consumeDynamicAccess:function(){return O},createDynamicTrackingState:function(){return l},createDynamicValidationState:function(){return y},createPostponedAbortSignal:function(){return U},formatDynamicAPIAccesses:function(){return j},getFirstDynamicReason:function(){return f},isDynamicPostpone:function(){return x},isPrerenderInterruptedError:function(){return P},markCurrentScopeAsDynamic:function(){return h},postponeWithTracking:function(){return A},throwIfDisallowedDynamic:function(){return q},throwToInterruptStaticGeneration:function(){return m},trackAllowedDynamicAccess:function(){return V},trackDynamicDataInDynamicRender:function(){return g},trackFallbackParamAccessed:function(){return p},trackSynchronousPlatformIOAccessInDev:function(){return b},trackSynchronousRequestDataAccessInDev:function(){return S},useDynamicRouteParams:function(){return W}});let r=function(e){return e&&e.__esModule?e:{default:e}}(n(3276)),a=n(9435),o=n(8851),i=n(3033),s=n(9294),c=n(584),u=n(7853),d="function"==typeof r.default.unstable_postpone;function l(e){return{isDebugDynamicAccesses:e,dynamicAccesses:[],syncDynamicExpression:void 0,syncDynamicErrorWithStack:null}}function y(){return{hasSuspendedDynamic:!1,hasDynamicMetadata:!1,hasDynamicViewport:!1,hasSyncDynamicErrors:!1,dynamicErrors:[]}}function f(e){var t;return null==(t=e.dynamicAccesses[0])?void 0:t.expression}function h(e,t,n){if((!t||"cache"!==t.type&&"unstable-cache"!==t.type)&&!e.forceDynamic&&!e.forceStatic){if(e.dynamicShouldError)throw new o.StaticGenBailoutError(`Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${n}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);if(t){if("prerender-ppr"===t.type)A(e.route,n,t.dynamicTracking);else if("prerender-legacy"===t.type){t.revalidate=0;let r=new a.DynamicServerError(`Route ${e.route} couldn't be rendered statically because it used ${n}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);throw e.dynamicUsageDescription=n,e.dynamicUsageStack=r.stack,r}}}}function p(e,t){let n=i.workUnitAsyncStorage.getStore();n&&"prerender-ppr"===n.type&&A(e.route,t,n.dynamicTracking)}function m(e,t,n){let r=new a.DynamicServerError(`Route ${t.route} couldn't be rendered statically because it used \`${e}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);throw n.revalidate=0,t.dynamicUsageDescription=e,t.dynamicUsageStack=r.stack,r}function g(e,t){t&&"cache"!==t.type&&"unstable-cache"!==t.type&&("prerender"===t.type||"prerender-legacy"===t.type)&&(t.revalidate=0)}function w(e,t,n){let r=v(`Route ${e} needs to bail out of prerendering at this point because it used ${t}.`);n.controller.abort(r);let a=n.dynamicTracking;a&&a.dynamicAccesses.push({stack:a.isDebugDynamicAccesses?Error().stack:void 0,expression:t})}function D(e,t,n,r){let a=r.dynamicTracking;return a&&null===a.syncDynamicErrorWithStack&&(a.syncDynamicExpression=t,a.syncDynamicErrorWithStack=n),w(e,t,r)}function b(e){e.prerenderPhase=!1}function E(e,t,n,r){let a=r.dynamicTracking;throw a&&null===a.syncDynamicErrorWithStack&&(a.syncDynamicExpression=t,a.syncDynamicErrorWithStack=n,!0===r.validating&&(a.syncDynamicLogged=!0)),w(e,t,r),v(`Route ${e} needs to bail out of prerendering at this point because it used ${t}.`)}let S=b;function k({reason:e,route:t}){let n=i.workUnitAsyncStorage.getStore();A(t,e,n&&"prerender-ppr"===n.type?n.dynamicTracking:null)}function A(e,t,n){I(),n&&n.dynamicAccesses.push({stack:n.isDebugDynamicAccesses?Error().stack:void 0,expression:t}),r.default.unstable_postpone(R(e,t))}function R(e,t){return`Route ${e} needs to bail out of prerendering at this point because it used ${t}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`}function x(e){return"object"==typeof e&&null!==e&&"string"==typeof e.message&&$(e.message)}function $(e){return e.includes("needs to bail out of prerendering at this point because it used")&&e.includes("Learn more: https://nextjs.org/docs/messages/ppr-caught-error")}if(!1===$(R("%%%","^^^")))throw Error("Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js");let T="NEXT_PRERENDER_INTERRUPTED";function v(e){let t=Error(e);return t.digest=T,t}function P(e){return"object"==typeof e&&null!==e&&e.digest===T&&"name"in e&&"message"in e&&e instanceof Error}function _(e){return e.length>0}function O(e,t){return e.dynamicAccesses.push(...t.dynamicAccesses),e.dynamicAccesses}function j(e){return e.filter(e=>"string"==typeof e.stack&&e.stack.length>0).map(({expression:e,stack:t})=>(t=t.split("\n").slice(4).filter(e=>!(e.includes("node_modules/next/")||e.includes(" (<anonymous>)")||e.includes(" (node:"))).join("\n"),`Dynamic API Usage Debug - ${e}:
${t}`))}function I(){if(!d)throw Error("Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js")}function U(e){I();let t=new AbortController;try{r.default.unstable_postpone(e)}catch(e){t.abort(e)}return t.signal}function M(e,t){let n=t.dynamicTracking;n&&n.dynamicAccesses.push({stack:n.isDebugDynamicAccesses?Error().stack:void 0,expression:e})}function W(e){{let t=s.workAsyncStorage.getStore();if(t&&t.isStaticGeneration&&t.fallbackRouteParams&&t.fallbackRouteParams.size>0){let n=i.workUnitAsyncStorage.getStore();n&&("prerender"===n.type?r.default.use((0,c.makeHangingPromise)(n.renderSignal,e)):"prerender-ppr"===n.type?A(t.route,e,n.dynamicTracking):"prerender-legacy"===n.type&&m(e,t,n))}}}let B=/\n\s+at Suspense \(<anonymous>\)/,N=RegExp(`\\n\\s+at ${u.METADATA_BOUNDARY_NAME}[\\n\\s]`),G=RegExp(`\\n\\s+at ${u.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`),L=RegExp(`\\n\\s+at ${u.OUTLET_BOUNDARY_NAME}[\\n\\s]`);function V(e,t,n,r,a){if(!L.test(t)){if(N.test(t)){n.hasDynamicMetadata=!0;return}if(G.test(t)){n.hasDynamicViewport=!0;return}if(B.test(t)){n.hasSuspendedDynamic=!0;return}if(r.syncDynamicErrorWithStack||a.syncDynamicErrorWithStack){n.hasSyncDynamicErrors=!0;return}else{let r=function(e,t){let n=Error(e);return n.stack="Error: "+e+t,n}(`Route "${e}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`,t);n.dynamicErrors.push(r);return}}}function q(e,t,n,r){let a,i,s;if(n.syncDynamicErrorWithStack?(a=n.syncDynamicErrorWithStack,i=n.syncDynamicExpression,s=!0===n.syncDynamicLogged):r.syncDynamicErrorWithStack?(a=r.syncDynamicErrorWithStack,i=r.syncDynamicExpression,s=!0===r.syncDynamicLogged):(a=null,i=void 0,s=!1),t.hasSyncDynamicErrors&&a)throw s||console.error(a),new o.StaticGenBailoutError;let c=t.dynamicErrors;if(c.length){for(let e=0;e<c.length;e++)console.error(c[e]);throw new o.StaticGenBailoutError}if(!t.hasSuspendedDynamic){if(t.hasDynamicMetadata){if(a)throw console.error(a),new o.StaticGenBailoutError(`Route "${e}" has a \`generateMetadata\` that could not finish rendering before ${i} was used. Follow the instructions in the error for this expression to resolve.`);throw new o.StaticGenBailoutError(`Route "${e}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateMetadata\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`)}if(t.hasDynamicViewport){if(a)throw console.error(a),new o.StaticGenBailoutError(`Route "${e}" has a \`generateViewport\` that could not finish rendering before ${i} was used. Follow the instructions in the error for this expression to resolve.`);throw new o.StaticGenBailoutError(`Route "${e}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateViewport\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`)}}}}};